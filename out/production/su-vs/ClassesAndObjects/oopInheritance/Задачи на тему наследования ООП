    1. Создайте класс "Employee" с полями "имя" (String), "возраст" (int), "зарплата" (double) и методом "toString()",
    который возвращает строковое представление объекта сотрудника, включая все его поля.

    2. Создайте подклассы "Manager" и "Developer", которые наследуют класс "Employee". Добавьте дополнительные поля и
    методы в подклассы, например, "отдел" (String) и "навыки" (массив строк) для "Manager", и "языки программирования"
    (массив строк) для "Developer".

    3. Создайте массив объектов "Employee", "Manager" и "Developer" с разными значениями полей для каждого объекта.

    4. Напишите методы в классах "Manager" и "Developer", которые рассчитывают и возвращают бонусную зарплату с учетом
    дополнительных полей и условий. Например, метод "calculateBonus()" в классе "Manager" может рассчитывать бонусную
    зарплату на основе размера отдела, а метод "calculateBonus()" в классе "Developer" - на основе количества языков
    программирования, которыми владеет разработчик.

    5. Напишите метод в классе "Employee", который выводит на консоль информацию о сотруднике, включая его бонусную
    зарплату,
    используя ранее созданные методы "calculateBonus()".

    6. Напишите метод в классе "Employee", который находит и возвращает самого старшего сотрудника из массива сотрудников.

    7. Напишите метод в классе "Employee", который находит и возвращает среднюю зарплату всех сотрудников из массива
    сотрудников.

    8. Напишите метод в классе "Employee", который находит и возвращает суммарную зарплату всех сотрудников из массива
    сотрудников.

    9. Напишите метод в классе "Employee", который находит и возвращает всех сотрудников, чья зарплата выше заданного
    значения.

    *10. Напишите метод в классе "Employee", который находит и возвращает всех сотрудников, чье имя начинается с заданной
    строки.

    11. Напишите метод в классе "Employee", который премирует всех сотрудников и добавляет прибавку к зарплате на 10%,
    а разработчикам на 15%

    12. Напишите метод в классе "Employee", который возвращает сумму всех зарплат сотрудников из массива сотрудников, если
    их возраст больше заданного значения.

    13. Напишите метод в классе "Employee", который определяет, является ли сотрудник менеджером, и возвращает
    соответствующее логическое значение (true/false) на основе наличия отдела у сотрудника.

    *14. Напишите метод в классе "Employee", который возвращает сумму всех зарплат сотрудников из массива сотрудников,
    если их имя содержит заданную подстроку.

    15. Напишите метод в классе "Employee", который увеличивает зарплату сотрудника на заданное значение.

    16. Напишите метод в классе "Employee", который определяет, является ли сотрудник старше другого сотрудника, и
    возвращает соответствующее логическое значение (true/false) на основе сравнения их возрастов.
    задается 2 сотрудника, любым образом, метод должен написать кто старше кого, и на сколько, либо они ровесники.

    17. Напишите метод в классе "Employee", который сортирует массив сотрудников по их зарплате в порядке убывания.
    для сортировки необходимо использовать метод сортировки пузырьком!

    18. Напишите метод в классе "Employee", который возвращает среднюю зарплату всех сотрудников младше заданного возраста.

    19. Напишите метод в классе "Employee", который возвращает количество сотрудников, чья зарплата находится в заданном
    диапазоне.

    20. Напишите метод в классе "Employee", который возвращает количество сотрудников в заданном отделе.

    21. Напишите метод в классе "Employee", который возвращает список всех сотрудников с заданным уровнем зарплаты.

    22. Напишите метод в классе "Employee", который определяет, есть ли среди сотрудников хотя бы один сотрудник с
    заданным именем, и возвращает соответствующее логическое значение (true/false).

    23. Напишите метод в классе "Employee", который определяет, являются ли два сотрудника коллегами, и возвращает
    соответствующее логическое значение (true/false) на основе их отдела и должности.

    24. Напишите метод в классе "Employee", который возвращает максимальную зарплату среди всех сотрудников.

    25. Напишите метод в классе "Employee", который возвращает список всех сотрудников, отсортированных по алфавиту
    по их фамилии.

    ===
    Одним из вариантов реализации может быть использование алгоритма сортировки вставками (insertion sort)
    внутри самого класса Employee.
    Пример реализации метода sortEmployeesByLastName() в классе Employee, который возвращает список всех сотрудников,
    отсортированных по алфавиту по их фамилии:

        public static void sortEmployeesByLastName(Employee[] employees) {
            if (employees == null || employees.length <= 1) {
                // Если массив пуст или содержит только один элемент, то он уже отсортирован
                return;
            }

            // Сортировка массива сотрудников методом вставками по фамилии
            for (int i = 1; i < employees.length; i++) {

                Employee key = employees[i];

                int j = i - 1;

                while (j >= 0 && employees[j].getSurname().compareToIgnoreCase(key.getSurname()) > 0) {

                  ===
                  В условии (j >= 0 && employees[j].getSurname().compareToIgnoreCase(key.getSurname()) > 0) используются
                  следующие выражения:

                 1) j >= 0: Это проверка на то, что индекс j массива employees не меньше 0. Таким образом, это условие
                  гарантирует, что мы не выйдем за пределы массива.

                 2) employees[j].getSurname().compareToIgnoreCase(key.getSurname()) > 0: Это сравнение фамилии сотрудника
                  с фамилией key методом compareToIgnoreCase(). Метод compareToIgnoreCase() сравнивает строки без учета
                  регистра символов и возвращает целое число, которое указывает на то, какая строка "меньше" или "больше"
                  в лексикографическом порядке. Если это значение больше 0, то это означает, что фамилия сотрудника
                  (employees[j].getSurname()) идет после фамилии key.getSurname() в алфавитном порядке.

                  Таким образом, данное условие
                  (j >= 0 && employees[j].getSurname().compareToIgnoreCase(key.getSurname()) > 0)
                  означает, что мы будем выполнять сортировку только тогда, когда индекс j в массиве employees
                  не меньше 0 и фамилия сотрудника employees[j] идет после фамилии key.getSurname() в алфавитном порядке
                  (без учета регистра).
                    ===

                    employees[j + 1] = employees[j];
                    j = j - 1;
                }
                employees[j + 1] = key;
            }

            compareTo() - это метод, определенный в интерфейсе Comparable, который позволяет сравнивать объекты
            на основе их естественного порядка. В Java, строковые значения (такие как фамилии) также имеют
            естественный порядок, определяемый лексикографическим порядком символов.

            Метод compareTo() возвращает целое число, которое имеет следующие значения:

            * Отрицательное число, если текущий объект (this) меньше объекта, с которым производится сравнение
            (переданный объект).
            * Нуль, если текущий объект равен объекту, с которым производится сравнение.
            * Положительное число, если текущий объект больше объекта, с которым производится сравнение.

            Если вызвать compareTo() на строковых значениях, то он будет сравнивать их лексикографически,
            основываясь на значениях их символов. В Java, сравнение строк регистронезависимо, то есть регистр символов
            не учитывается по умолчанию. Если нужно учитывать регистр, то можно использовать метод
            compareToIgnoreCase().

            В примере кода, который я предоставил ранее, метод compareTo() используется для сравнения фамилий
            сотрудников в методе sortEmployeesByLastName(). Если фамилия текущего сотрудника идет после фамилии
            следующего сотрудника в алфавитном порядке, то сотрудники меняются местами в массиве с использованием
            алгоритма сортировки пузырьком.
    ===
    // Создаем массив сотрудников
    Employee employee1 = new Employee("Иван", "Иванов", "01.01.1980", 5000);
    Employee employee2 = new Employee("Петр", "Петров", "15.03.1975", 4000);
    Employee employee3 = new Employee("Анна", "Сидорова", "10.12.1990", 5500);
    Employee[] employees = {employee1, employee2, employee3};

    // Выводим информацию о сотрудниках до сортировки
    System.out.println("Сотрудники до сортировки:");
    for (Employee employee : employees) {
        System.out.println("Имя: " + employee.getName() + ", Фамилия: " + employee.getSurname());
    }

    // Вызываем метод sortEmployeesByLastName() для сортировки сотрудников по фамилии
    Employee.sortEmployeesByLastName(employees);

    // Выводим информацию о сотрудниках после сортировки
    System.out.println("Сотрудники после сортировки:");
    for (Employee employee : employees) {
        System.out.println("Имя: " + employee.getName() + ", Фамилия: " + employee.getSurname());
    }
    ===

    26. Напишите метод в классе "Employee", который определяет, является ли сотрудник активным, и возвращает
    соответствующее логическое значение (true/false) на основе статуса сотрудника (например, наличия даты увольнения).

    27. Напишите метод в классе "Employee", который возвращает список всех сотрудников, у которых зарплата выше средней
    зарплаты всех сотрудников.

